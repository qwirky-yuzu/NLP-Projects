# Seq2Seq-Model (Pytorch)

# 1. Introduction and Dataset
South Park is an American animated sitcom that is generally intended for adult audiences as strong profanity and taboo words are often used. Utilizing their scripts available online, our team created a chatbot where users are able to communicate freely with the iconic South Park character. The scripts are based predominantly on dialogue exchanges between South Park Characters across different episodes which will form the questions and responses. With this chatbot, users can engage in social conversations with a South Park-like character and experience his conversational behaviour in real time.
The dataset is formed from a corpus of conversational exchanges between characters in South Park, containing over 70,000 dialogue lines curated over 18 seasons. The uniqueness of this dataset stems from how characters have thier unique punchlines, way of conversation and making jokes. The data collectors, mostly fans, had opportunistically curated as much metadata of every characters’ conversations over 18 seasons of the sitcom. This ensured the completeness of the  dataset enabling a robust and effective chatbot to be built. 

# 2. Model Architecture: Seq2Seq with Gated Recurrent Units (GRU)
The Seq2Seq model was built using PyTorch. In the model, each input word was parsed into an encoder made up of a stack of several GRUs. We used a bidirectional variant of the GRU, where two independent RNNs - one is fed the input sequence in normal sequential order, and another is fed the input sequence in reverse order. The outputs of each network are summed at each time step. This provides the advantage of encoding both past and future context. In the embedding layer, our team encoded the word indices in an arbitrarily sized feature space where each word is mapped to a feature space and during training, these values would encode semantic similarity between similar meaning words. 

![Figure 1](images/RNN-bidirectional.png)

# 3. Data pre-processing
For each sentence, we removed new line characters, expanded contractions and lemmatized the words to their root form. Each word is assigned a token - PAD, SOS or EOS that matches its position. These sentences are transformed into sentence pairs and written into a text file (Figure 6). Sentences that were below the threshold of 20 words were removed from the corpus. This threshold value was derived from Exploratory Data Analysis where we found that 90% of all sentences are less than or equal to 20 words. The vocabulary corpus was created and each query-response sentence pair was loaded into memory. Rare words removal, as proposed by Krass, M. S., was done to remove words that appear 3 times or less out of the vocabulary space. Decreasing this feature space allowed the model to approximate in an easier manner, achieving faster convergence during training. As sequences of words do not have an implicit mapping to a discrete numerical space, we created it by mapping each unique word to an index value. The output was then sent into a tensor unit for training. 

# 4. Testing and Evaluation
To test and evaluate the model, an “evaluate” function was written to manage low-level processes of handling the input sentence. The sentence is first formatted as an input batch of word indexes with batch size of 1 by converting words in the sentence to their corresponding indexes and transposing the dimensions to prepare the tensor to be fed into the model. The decoded response sentence tensor and the responses’ indexes are converted to words and returned as output. To create a simple user interface with the chatbot, the team created a function which will prompt an input text field, allowing the user to enter a query sentence. This will be fed into the “evaluate” function to obtain a decoded output sentence. An iterative process, the user continuously interacts with the chatbot until he types either “q” or “quit”.

# 5. Sample input query sentences
The following table shows 10 input query sentences and their responses generated by the system:

| SN        | User Query           | Bot Response  |
| ------------- |:-------------:| -----:|
| 1   | hello! | hi guys  |
| 2    | how are you?      |   bad ! |
| 3   | are you okay?|haaaa . yes thank you .
| 4 | are you sure?      |    ahi am sure . let s get a cup of coffee . |
| 5 | where shall we go?      |    we ve got to get out of town . go through that way . |
| 6 | you are stupid and dumb   |    yeah and you are a drunk man ! |
| 7 | you are a bad kid      |    that is right ! i am gonna kick your ass !|
| 8 | you are an asshole     |    i am sorry . |
| 9 | i am getting pretty sick of you now!    |    oh yeah ? ! i am not your buddih friend ! |
| 10 | bye bye    |    great to see you ! |

# 6. References
1. https://pytorch.org/tutorials/beginner/deploy_seq2seq_hybrid_frontend_tutorial.html

